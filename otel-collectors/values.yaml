# Default values for OpenTelemetry Collector Stack

## Global settings
global:
  clusterName: "kind-cluster"
  environment: "production"
  namespace: o11y

## Health Check Probes Configuration
healthChecks:
  livenessProbe:
    enabled: true
    httpGet:
      path: /
      port: 13133
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
  readinessProbe:
    enabled: true
    httpGet:
      path: /
      port: 13133
    initialDelaySeconds: 10
    periodSeconds: 5
    timeoutSeconds: 3
    failureThreshold: 3

## Multiple OTLP Destinations Configuration
## Each destination can handle traces, metrics, and/or logs via OTLP protocol
otlpDestinations:
  # Primary destination (backward compatibility with grafanaCloud)
  grafanaCloud:
    enabled: true
    endpoint: "https://otlp-gateway-prod-us-central-0.grafana.net/otlp"
    # Secret configuration - choose one of two options:
    # Option 1: Use existing secret (recommended for production)
    authSecretName: "grafana-cloud-secret"  # Name of existing secret (required if createSecret is false)
    # Option 2: Create secret from values (NOT recommended for production)
    createSecret: false  # Set to true to create secret from username/password below
    username: ""  # Only used if createSecret is true
    password: ""  # Only used if createSecret is true
    signals: ["traces", "metrics", "logs"]  # Which signals to send to this destination
    
  # Additional OTLP destinations can be added here
  # Examples:
  # jaeger:
  #   enabled: false
  #   endpoint: "http://jaeger:4318"
  #   authSecretName: "jaeger-auth"
  #   signals: ["traces"]
  #
  # loki:
  #   enabled: false  
  #   endpoint: "http://loki:3100/otlp"
  #   authSecretName: "loki-auth"
  #   signals: ["logs"]
  #
  # prometheus:
  #   enabled: false
  #   endpoint: "http://prometheus:3100/otlp"
  #   authSecretName: "prometheus-auth" 
  #   signals: ["metrics"]

## Legacy Grafana Cloud Configuration (deprecated, use otlpDestinations.grafanaCloud instead)
grafanaCloud:
  endpoint: ""
  authSecretName: ""
  usernameKey: ""
  passwordKey: ""
  createSecret: false

## Common Collector Settings (defaults for all collectors)
collectorsCommon:
  image:
    repository: ghcr.io/open-telemetry/opentelemetry-collector-releases/opentelemetry-collector-contrib
    tag: "0.138.0"
  resources:
    limits:
      memory: 1Gi
      cpu: 500m
    requests:
      memory: 512Mi
      cpu: 200m
  serviceAccount: otel-collector

readinessProbe:
  enabled: true

## Application Observability Configuration
applicationObservability:
  receiver:
    transform:
      traces:
        enabled: false
        transforms:
          resource: []
          span: []
      metrics:
        enabled: false
        filters:
          datapoint: []
        transforms:
          datapoint: []
      logs:
        enabled: false
        transforms:
          log: []
  
  spanmetrics:
    transform:
      metrics:
        enabled: false
        filters:
          datapoint: []
        transforms:
          datapoint: []
  
  servicegraph:
    transform:
      metrics:
        enabled: false
        filters:
          datapoint: []
        transforms:
          datapoint: []
  
  tailsampling:
    policies:
      enabled: false
      # List of tail sampling policies - supports all OpenTelemetry tail sampling policy types
      list: []
      # Examples of all supported policy types:
      # list:
      #   # Always sample certain traces
      #   - name: always-sample-critical
      #     type: always_sample
      #
      #   # Sample based on latency
      #   - name: slow-requests
      #     type: latency
      #     latency:
      #       threshold_ms: 2000
      #
      #   # Sample based on numeric attributes
      #   - name: high-value-transactions
      #     type: numeric_attribute
      #     numeric_attribute:
      #       key: transaction.amount
      #       min_value: 1000
      #       max_value: 10000
      #
      #   # Probabilistic sampling
      #   - name: random-sample
      #     type: probabilistic
      #     probabilistic:
      #       hash_salt: custom-salt
      #       sampling_percentage: 10
      #
      #   # Sample based on status codes
      #   - name: errors-only
      #     type: status_code
      #     status_code:
      #       status_codes: [ERROR, UNSET]
      #
      #   # Sample based on string attributes
      #   - name: important-services
      #     type: string_attribute
      #     string_attribute:
      #       key: service.name
      #       values: [auth-service, payment-service]
      #
      #   # Rate limiting
      #   - name: rate-limit
      #     type: rate_limiting
      #     rate_limiting:
      #       spans_per_second: 100
      #
      #   # Sample based on span count
      #   - name: complex-traces
      #     type: span_count
      #     span_count:
      #       min_spans: 10
      #       max_spans: 1000
      #
      #   # Sample based on trace state
      #   - name: trace-state-sample
      #     type: trace_state
      #     trace_state:
      #       key: sampling
      #       values: [enabled, priority]
      #
      #   # Sample based on boolean attributes
      #   - name: debug-traces
      #     type: boolean_attribute
      #     boolean_attribute:
      #       key: debug.enabled
      #       value: true
      #
      #   # Sample based on OTTL conditions
      #   - name: ottl-condition
      #     type: ottl_condition
      #     ottl_condition:
      #       error_mode: ignore
      #       span:
      #         - 'attributes["http.status_code"] >= 400'
      #       spanevent:
      #         - 'name == "exception"'
      #
      #   # AND policy (all sub-policies must match)
      #   - name: errors-and-slow
      #     type: and
      #     and:
      #       and_sub_policy:
      #         - name: error-policy
      #           type: status_code
      #           status_code:
      #             status_codes: [ERROR]
      #         - name: latency-policy
      #           type: latency
      #           latency:
      #             threshold_ms: 1000
      #
      #   # Composite policy (multiple evaluation criteria)
      #   - name: composite-sample
      #     type: composite
      #     composite:
      #       max_total_spans_per_second: 1000
      #       policy_order: [errors-policy, latency-policy, probabilistic-policy]
      #       composite_sub_policy:
      #         - name: errors-policy
      #           type: status_code
      #           status_code:
      #             status_codes: [ERROR]
      #         - name: latency-policy  
      #           type: latency
      #           latency:
      #             threshold_ms: 500
      #         - name: probabilistic-policy
      #           type: probabilistic
      #           probabilistic:
      #             sampling_percentage: 5
    transform:
      traces:
        enabled: false
        transforms:
          resource: []
          span: []

## Collector Definitions
collectors:
  # Application Observability Collectors
  receiver:
    enabled: true
    type: application
    replicas: 1
    mode: deployment
    resources:
      limits:
        memory: 512Mi
        cpu: 500m
      requests:
        memory: 256Mi
        cpu: 200m
    config:
      workloadName: "receiver"
      receivers: ["otlp", "filelog"]
      processors: ["memory_limiter", "k8sattributes", "resource", "batch"]
      exporters: ["otlphttp"]  # Direct export to OTLP destinations

  tailsampling:
    enabled: false  # Optional: Enable for advanced trace sampling
    type: application
    replicas: 2
    mode: statefulset
    resources:
      limits:
        memory: 8Gi
        cpu: 500m
      requests:
        memory: 1Gi
        cpu: 200m
    config:
      workloadName: "tailsampling"
      samplingRate: 0.5
      decisionWait: "10s"
      receivers: ["otlp"]
      processors: ["memory_limiter", "resource/add_workload_name", "tail_sampling", "batch"]
      exporters: ["otlphttp/grafanacloud"]

  spanmetrics:
    enabled: false  # Optional: Enable to generate RED metrics from spans
    type: application
    replicas: 2
    mode: statefulset
    serviceAccount: otel-collector
    resources:
      limits:
        memory: 8Gi
        cpu: 500m
      requests:
        memory: 1Gi
        cpu: 200m
    config:
      workloadName: "spanmetrics"
      receivers: ["otlp"]
      processors: ["memory_limiter", "resource/add_collector_info", "filter/spanmetrics_only", "batch"]
      exporters: ["otlphttp/grafanacloud"]

  servicegraph:
    enabled: false  # Optional: Enable to generate service dependency graphs
    type: application
    replicas: 2
    mode: statefulset
    serviceAccount: otel-collector
    resources:
      limits:
        memory: 8Gi
      requests:
        memory: 1Gi
        cpu: 200m
    config:
      workloadName: "servicegraph"
      flushInterval: "60s"
      receivers: ["otlp"]
      processors: ["memory_limiter", "resource/add_collector_info", "batch"]
      exporters: ["otlphttp/grafanacloud", "debug"]

  # Infrastructure Observability Collectors
  cluster-metrics:
    enabled: false  # Optional: Enable to collect Kubernetes cluster metrics
    type: infrastructure
    replicas: 3
    mode: statefulset
    resources:
      limits:
        memory: 2Gi
        cpu: 1
      requests:
        memory: 1Gi
        cpu: 500m
    targetAllocator:
      enabled: true
    config:
      workloadName: "cluster"
      receivers: ["k8s_cluster", "prometheus"]
      processors: ["memory_limiter", "resource", "batch"]
      exporters: ["otlphttp/grafanacloud"]

  node-metrics:
    enabled: false  # Optional: Enable to collect node-level metrics
    type: infrastructure
    replicas: 1
    mode: daemonset
    serviceAccount: otel-collector
    resources:
      limits:
        memory: 256Mi
        cpu: 200m
      requests:
        memory: 128Mi
        cpu: 100m
    config:
      workloadName: "nodes"
      receivers: ["kubeletstats", "prometheus"]
      processors: ["memory_limiter", "filter/kubeletstats_allowlist", "resource", "batch"]
      exporters: ["otlphttp/grafanacloud"]

## Allowlists
allowlists:
  cadvisor:
    enabled: true
  kubelet:
    enabled: true
  kubeStateMetrics:
    enabled: true
  nodeExporter:
    enabled: false
  kubeletstats:
    enabled: true
  otelCollector:
    enabled: true

## Dependencies
kubeStateMetrics:
  enabled: false
  fullnameOverride: "kube-state-metrics"

nodeExporter:
  enabled: false
  fullnameOverride: "node-exporter"
  service:
    port: 9100
    portName: metrics
  hostNetwork: true
  hostPID: true
  
## RBAC
rbac:
  create: true

## Validation
validation:
  enabled: true
  skipOperatorCheck: false
  skipConnectivityTest: false

## Security Configuration
security:
  # Pod Security Context - Applied at pod level
  podSecurityContext:
    runAsUser: 65534         # nobody user
    runAsGroup: 65534        # nobody group
    runAsNonRoot: true       # Prevent running as root
    fsGroup: 65534           # File system group for volume ownership
    fsGroupChangePolicy: "OnRootMismatch"  # Change ownership only when needed
    supplementalGroups: []   # Additional groups for the container processes
    seccompProfile:
      type: RuntimeDefault   # Use runtime default seccomp profile
    # SELinux context (uncomment and configure if SELinux is used)
    # seLinuxOptions:
    #   level: "s0:c123,c456"
    # sysctls: []            # Sysctls and their values
  
  # Container Security Context - Applied at container level
  containerSecurityContext:
    # User and group settings
    runAsUser: 65534         # Override pod runAsUser if needed
    runAsGroup: 65534        # Override pod runAsGroup if needed
    runAsNonRoot: true       # Prevent container from running as root
    
    # Privilege settings
    allowPrivilegeEscalation: false  # Prevent privilege escalation
    privileged: false               # Ensure container is not privileged
    
    # Filesystem settings
    readOnlyRootFilesystem: true    # Make root filesystem read-only
    
    # Linux capabilities - drop all by default
    capabilities:
      drop:
        - ALL                # Drop all capabilities
      # add: []              # Add only specific capabilities if needed
      
    # Security profiles
    seccompProfile:
      type: RuntimeDefault   # Use runtime default seccomp profile
    # AppArmor profile (uncomment if AppArmor is used)
    # appArmorProfile:
    #   type: RuntimeDefault
    # SELinux context (container level override)
    # seLinuxOptions:
    #   level: "s0:c123,c456"
    
    # Process settings
    procMount: Default       # How proc filesystem is mounted

  # Advanced Security Settings (optional, environment-specific)
  advanced:
    # Pod Security Standards compliance level
    podSecurityStandard: "restricted"  # baseline, restricted, or privileged
    
    # Additional security annotations
    annotations:
      # Container runtime security profiles
      # container.apparmor.security.beta.kubernetes.io/otel-collector: "runtime/default"
      # seccomp.security.alpha.kubernetes.io/pod: "runtime/default"
    
    # Network security
    hostNetwork: false       # Disable host network access
    
    # Volume security
    allowedVolumeTypes:
      - configMap
      - secret  
      - emptyDir
      - projected
      - downwardAPI
    
    # Seccomp profiles (if custom profiles are needed)
    seccompProfiles:
      custom:
        type: Localhost
        localhostProfile: "profiles/audit.json"
  

## Health Probes
healthProbes:
  enabled: true
  readiness:
    initialDelaySeconds: 10
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 3
  liveness:
    initialDelaySeconds: 30
    periodSeconds: 30
    timeoutSeconds: 10
    failureThreshold: 3
  
## Service Account
serviceAccount:
  create: true
  name: otel-collector

## Histogram Configuration
histograms:
  buckets: [0.1, 0.5, 1, 2, 5]

## Common Configuration
imagePullSecrets: []
commonLabels: {}
commonAnnotations: {}